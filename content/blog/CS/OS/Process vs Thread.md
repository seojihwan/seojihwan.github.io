---
title: '[CS] Process vs Thread' 
date: 2020-10-17 18:10:36
category: 'CS'
draft: false
---


### 프로세스: 실행 중인 프로그램

프로그램을 실행하면 프로세스는 프로그램에 기록된 작업을 수행한다.


프로세스의 메모리 구조
- 스택: 데이터(메서드, 함수 매개변수, 반환 주소, local 변수 등 임시 데이터)를 일시적으로 저장, 함수를 호출할수록 커지고 반환하면 줄어든다.
- 힙: 런타임에 프로세스에 동적으로 할당된 메모리 영역 
- 데이터: 가상 주소 공간 global, static 변수 저장, 프로그램 실행 후 변수 초기화 
- 코드: 컴파일된 프로그램이 저장되고, 읽기 전용, 공유 가능한 영역이다.

스택에서는 local 변수, 데이터섹션 에서는 global, static 변수를 포함한다고하는데 이 차이를 알아보자

#####  local 변수, global, static 변수 차이

2가지 관점에서 3가지 변수의 차이를 구별할 수 있다.

- scope: 접근 가능한 영역
- stoarge duration: 변수가 만들어지고 사라지는 시점

###### local 변수
같은 블록 또는 하위 scope에서 접근 가능, 코드의 실행영역이 해당 scope를 벗어나면 local 변수는 사라진다.

###### global 변수
최 상단 scope에서 정의 되었기 때문에 모든 scope에서 접근 가능하다. scope가 최 상단이기 때문에 프로그램이 끝날때 까지 사라지지 않는다.

###### static 변수
같은 블록 또는 하위 scope에서 접근가능, 프로그램이 끝날때 까지 사라지지 않는다.

[local vs global vs static](https://stackoverflow.com/questions/13415321/difference-between-static-auto-global-and-local-variable-in-the-context-of-c-a)


### 프로세스의 상태 

- 준비
- 실행
- 대기

#### 프로세스의 상태 변화

- 생성 -> `준비`

운영체제가 프로세스를 생성하면 준비 큐에 들어가고, 준비 상태가 된다.

- `준비` -> `실행`

준비 큐 맨 앞의 프로세스는 프로세서를 점유(dispatch)하여 실행 상태가 된다.
프로세스가 프로세서를 독점하는 것을 방지하기 위해 인터럽트 클록을 사용한다.

- `실행` -> `준비`

프로세스에 할당된 시간이 지나면 인터럽트 클록이 인터럽트를 발생시켜 해당 프로세스를 준비 상태로 바꾼다.

- `실행` -> `대기`

실행 상태의 프로세스에 입출력 연산, 자원 요청이 발생한 경우 해당 프로세스는 대기 상태가 된다.

- `대기` -> `준비`

입 출력 연산이 끝나면 대기 상태(wake up)에서 준비상태로 돌아간다.

- `실행` -> 종료

작업이 끝난 프로세스는 메모리 공간을 반환하고 삭제된다.

각 프로세스의 상태 정보는 프로세스 제어 블록에 저장된다.

#### 프로세스 제어블록(PCB)

운영체제는 스케줄러를 통해 프로세스를 관리 제어하고 이때 각 프로세스에 있는 제어블록을 이용한다.

프로세스 제어 블록은 프로세스와 함께 생성되고 프로세스가 종료될 때 같이 삭제된다.
프로세스 제어 블록에는 다음과 같은 정보가 저장된다.

- 프로세스 식별자: 각 프로세스의 고유 식별자
- 프로세스 상태: 프로세스의 상태(생성, 준비, 실행, 대기, 중단)
- 프로그램 카운터: 프로세스를 실행하는 다음 명령의 주소
- 레지스터 저장 영역: 인터럽트가 발생하고 재실행 될때 프로그램 카운터와 함께 원래의 작업을 유지할 수 있도록 도움
- 프로세서 스케줄링 정보: 프로세스 우선순위, 스케줄링 큐 포인터, 기타 매개변수
- 계정 정보: 프로세스 사용 시간, 실 사용시간, 상한 시간, 프로세스 번호 등
- 입출력 상태 정보, 메모리 관리 정보: 할당된 입출력장치, 상 하한 레지스터, 페이지 테이블, 세그먼트 테이블 값 등


#### 프로세스 문맥 교환
프로세스A에 인터럽트가 발생하면 A의 상태를 PCB(A)에 저장하고, PCB(B)의 정보를 통해 프로세스 B를 진행한다.


###### 레지스터

레지스터는 메모리 계층의 최상위에 위치하며, 가장 빠른 속도로 접근 가능한 메모리이다. 

대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는 로드-스토어 설계를 사용한다.

### 스레드: 프로세스의 실행 단위
스레드는 하나의 프로세스 내에서 자원을 공유한다.

프로세스 내의 코드, 전역 데이터, 힙을 다른 스레드와 공유한다.
프로그램 카운터, 스택 포인터, 문맥 정보, 지역 데이터, 스택은 스레드마다 독립적으로 갖는다.


또한 멀티 스레딩을 통해 독립적인 작업 수행으로 수행능력을 향상시킬 수 있다.

프로세스는 자원과 제어가 독립적이지만 스레드는 자원(코드, 전역 데이터, 힙)을 공유하고 제어만 독립적이다.
프로세스 내의 스레드들은 프로세서의 자원을 공유하고, 같은 주소 공간에 있으며, 동일 한 데이터에 접근한다.
이러한 특성 때문에 프로세스보다 스레드의 생성, 교환, 종료가 훨씬 빠르다.
따라서 프로세스의 문맥 교환보다 스레드의 문맥 교환을 이용하는 것이 효율적이다.

###### 출처: 그림으로 배우는 구조와 원리 운영체제 - 구현회